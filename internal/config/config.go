package config

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"gopkg.in/yaml.v3"
)

// Config holds gcpspectre configuration loaded from .gcpspectre.yaml.
type Config struct {
	Projects       []string `yaml:"projects"`
	IdleDays       int      `yaml:"idle_days"`
	StaleDays      int      `yaml:"stale_days"`
	MinMonthlyCost float64  `yaml:"min_monthly_cost"`
	Format         string   `yaml:"format"`
	Timeout        string   `yaml:"timeout"`
	Exclude        Exclude  `yaml:"exclude"`
}

// Exclude defines resources to skip during scanning.
type Exclude struct {
	ResourceIDs []string `yaml:"resource_ids"`
	Labels      []string `yaml:"labels"`
}

// TimeoutDuration parses the timeout string as a duration.
func (c Config) TimeoutDuration() time.Duration {
	if c.Timeout == "" {
		return 0
	}
	d, _ := time.ParseDuration(c.Timeout)
	return d
}

// Load searches for .gcpspectre.yaml or .gcpspectre.yml in the given directory
// and returns the parsed config. Returns an empty Config if no file is found.
func Load(dir string) (Config, error) {
	candidates := []string{
		filepath.Join(dir, ".gcpspectre.yaml"),
		filepath.Join(dir, ".gcpspectre.yml"),
	}

	for _, path := range candidates {
		data, err := os.ReadFile(path)
		if err != nil {
			if os.IsNotExist(err) {
				continue
			}
			return Config{}, fmt.Errorf("read config %s: %w", path, err)
		}

		var cfg Config
		if err := yaml.Unmarshal(data, &cfg); err != nil {
			return Config{}, fmt.Errorf("parse config %s: %w", path, err)
		}
		return cfg, nil
	}

	return Config{}, nil
}
